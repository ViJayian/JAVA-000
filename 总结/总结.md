# 知识体系回顾总结

[TOC]



# 1.Jvm复习

## 1.Jvm基础知识

- Java是一种面向对象、静态类型、编译执行、有VM/GC和运行时、跨平台的高级语言
- Java二进制文件跨平台
- 兼容性好：低版本编译的jar包，放到高版本运行没有问题
- java生态好，解决方案多

## 2.Java字节码技术

字节码、类加载器、虚拟机

### 1.HelloWorld.java如何加载的？

- 生成字节码文件
- 虚拟机从文件系统中加载（通过类加载器加载）字节码文件，生成一个类，放到内存

### 2.字节码

Java bytecode由单字节（byte）的指令组成，理论最多支持256，实际只使用了200左右的。

根据指令性质，分为4大类（Jvm是基于栈的虚拟机，所有的计算都是在栈计算的）

- 栈操作指令
- 程序流程 if/for/while
- 对象操作
- 算术及类型转换

### 3.字节码文件剖析

- 编译

- 通过javap -c生成字节码文件

字节码文件都是助记符（如aload_0，对应一个byte的字节码（假如74）），在jvm中除了栈，还有本地变量表，运行时将变量加载到栈上，运行完后，将结果store到本地变量表。

int long赋值都是原子操作，32位long分成两个32位赋值，需要两次赋值，可能出错，64位不会出现这个问题。

子类重写了父类的方法，不管对象的实例指向谁，调用的都是子类的方法（invokevirual）

## 3.Jvm类加载器

### 1.类的生命周期

1. 加载
2. 链接（校验-准备-解析）
3. 初始化
4. 使用
5. 卸载

### 2.类的加载时机

1. 启动main方法所在的类
2. new对象
3. 调用静态方法时，初始化静态方法所在的类
4. 访问静态字段，初始化静态字段所在的类
5. 子类初始化触发父类初始化
6. default方法所在的接口，直接或者间接实现的类初始化，该接口初始化
7. 反射需要加载类
8. java.lang.invoke.MethodHandles，java7引入的概念，性能上比反射快，初次调用MethodHandle实例，会初始化指向方法所在的类

### 3.类加载但是不会初始化的情况

### 4.类加载器的分类

1. 启动类加载器（BootstrapClassLoader）rt.jar
2. 扩展类加载器（ExtClassLoader）
3. 应用类加载器（AppClassLoader）加载自己写的

> 加载器特点：
>
> 1. 双亲委托：应用类加载器加载类的时候，去找父加载器看有没有
> 2. 负责依赖：加载一个类，加载这个类依赖的类
> 3. 缓存加载：类只会被加载一次，之后就被缓存起来了

### 5.ClassLoader加载了哪些Jar

jar包和class文件组成的文件夹压缩是一样的

- 启动类加载器：jre/lib/rt.jar（jdk）
- 扩展类加载器：jre/lib/ext 下的jar包
- 应用类加载器：自己创建的

### 6.添加引用类的几种方式

1. jdk lib/ext
2. java -cp/classpath
3. 自定义ClassLoader
4. 当前的ClassLoader，反射调用addUrl

## 4.Jvm内存模型

- Jvm内存基于堆栈

- 栈数据每个线程独立
- 堆上的对象多线程共享

> 内存结构图

### 1.栈内存

- Xmx最大堆内存（不超过总内存的70%） Xms最小堆内存 Xss线程栈
- JNI（java native interface）：调用了本地方法，会分配本地方法栈
- 每个方法都有对应的方法栈和本地变量表（可以看做小虚拟机）

### 2.堆内存

1. 堆分为年轻代和老年代，刚创建的对象在年轻代，经过多次gc没有被回收的在老年代，为什么这么设计？因为绝大部分的对象生命周期都很短，可能创建出来就用一下。
2. 年轻代分为（新生代<Eden>，存活区）,存活区分（s0，s1），总有一个是空的，因为在垃圾回收的时候，某一个区垃圾回收部分后，会产生大量内存碎片，都搬到另外一个码好，解决这种问题。
3. 非堆：java8改名叫Metaspace（以前的持久代），class文件在元数据区存放

### 3.JMM（Java Memory Model）

java对象模型

线程之间的交互操作

## 5.Jvm启动参数

1. -开头的是标准参数
2. -D系统参数
3. -X非标准参数
4. -XX非稳定参数
5. -XX ：+flag
6. -XX：key value形式

# 2.GC

## 1.sdfdsf